--- genostream/encoding.py	2025-12-13 07:25:50.444670540 +0000
+++ genostream/encoding.py	2025-12-13 07:37:08.711218102 +0000
@@ -226,146 +226,238 @@
         aas.append(CODON_TO_AA.get(cod, "X"))
     return "".join(aas)
 
-def extract_cds_proteins_from_genbank(path: str, min_aa: int = 90) -> List[str]:
-    """
-    Extract protein sequences from GenBank FEATURES/CDS.
+def extract_cds_proteins_from_genbank(
+    path: str,
+    min_aa: int = 90,
+    max_aa: int | None = None,
+    require_translation: bool = False,
+    reject_partial: bool = True,
+    require_start_m: bool = True,
+    x_free: bool = True,
+) -> tuple[list[str], dict[str, int]]:
+    """Extract proteins from a GenBank flatfile's CDS features.
+
+    This parser is purposely lightweight (no Biopython). It understands:
+      - FEATURES / CDS blocks
+      - /translation="..." qualifiers (possibly multiline)
+      - /codon_start=N qualifier
+      - complement(...) locations
+
+    If /translation is missing and require_translation=False, it will try to
+    translate from the ORIGIN DNA using the CDS location.
 
-    Preference order per CDS:
-      1) /translation="..." qualifier (most reliable)
-      2) location + ORIGIN DNA + /codon_start (fallback)
-
-    Notes:
-      - Skips CDS with /pseudo or /pseudogene.
-      - Handles common location forms: 123..456, complement(123..456), join(...), complement(join(...)).
+    Returns (proteins, stats) where stats is a dict of counters.
     """
-    if not os.path.exists(path):
-        raise FileNotFoundError(f"GenBank not found: {path}")
+    import re
+
+    # Local imports to avoid heavy dependencies
+    valid_set = set(AA_ALPHABET)  # 20 standard AAs
+
+    stats: dict[str, int] = {
+        "cds_total": 0,
+        "cds_pseudo": 0,
+        "cds_partial": 0,
+        "cds_no_translation": 0,
+        "cds_no_origin": 0,
+        "prot_from_translation": 0,
+        "prot_from_dna": 0,
+        "prot_kept": 0,
+        "prot_too_short": 0,
+        "prot_too_long": 0,
+        "prot_bad_start": 0,
+        "prot_has_x": 0,
+        "prot_invalid_chars": 0,
+        "prot_internal_stop": 0,
+    }
 
-    # Parse ORIGIN DNA once for fallback translation
     try:
         origin_dna = parse_genbank_dna(path)
     except Exception:
         origin_dna = ""
 
-    proteins: List[str] = []
+    proteins: list[str] = []
+
     in_features = False
     in_origin = False
 
-    cur_loc: Optional[str] = None
-    cur_translation: Optional[str] = None
+    cur_loc_raw: str | None = None
+    cur_translation: str | None = None
     cur_codon_start: int = 1
     cur_is_pseudo: bool = False
     reading_translation = False
-    trans_buf: List[str] = []
+    trans_buf: list[str] = []
+
+    def _normalize_prot(s: str) -> str:
+        # Remove all whitespace, uppercase.
+        s2 = "".join(s.split()).strip().upper()
+        # Strip surrounding quotes if any
+        if s2.startswith('"') and s2.endswith('"') and len(s2) >= 2:
+            s2 = s2[1:-1]
+        # Remove trailing stop marker
+        if s2.endswith('*'):
+            s2 = s2[:-1]
+        return s2
+
+    def _passes_filters(prot: str) -> bool:
+        if not prot:
+            return False
+        if '*' in prot:
+            stats["prot_internal_stop"] += 1
+            return False
+        L = len(prot)
+        if L < int(min_aa):
+            stats["prot_too_short"] += 1
+            return False
+        if max_aa is not None and L > int(max_aa):
+            stats["prot_too_long"] += 1
+            return False
+        if require_start_m and not prot.startswith('M'):
+            stats["prot_bad_start"] += 1
+            return False
+        if x_free and ('X' in prot):
+            stats["prot_has_x"] += 1
+            return False
+        for ch in prot:
+            if ch in valid_set:
+                continue
+            if (not x_free) and ch == 'X':
+                continue
+            stats["prot_invalid_chars"] += 1
+            return False
+        return True
+
+    def _flush_current() -> None:
+        nonlocal cur_loc_raw, cur_translation, cur_codon_start, cur_is_pseudo, reading_translation, trans_buf
 
-    def flush_cds():
-        nonlocal cur_loc, cur_translation, cur_codon_start, cur_is_pseudo, reading_translation, trans_buf
-        if cur_loc is None:
+        if cur_loc_raw is None:
             return
+        stats["cds_total"] += 1
+
+        loc_raw = cur_loc_raw
+
         if cur_is_pseudo:
-            # reset
-            cur_loc = None; cur_translation = None; cur_codon_start = 1; cur_is_pseudo = False
-            reading_translation = False; trans_buf = []
+            stats["cds_pseudo"] += 1
+            cur_loc_raw = None
+            cur_translation = None
+            reading_translation = False
+            trans_buf = []
+            return
+
+        if reject_partial and ('<' in loc_raw or '>' in loc_raw):
+            stats["cds_partial"] += 1
+            cur_loc_raw = None
+            cur_translation = None
+            reading_translation = False
+            trans_buf = []
             return
 
-        prot = ""
-        if cur_translation:
-            prot = cur_translation
-        elif origin_dna:
-            cds_dna = extract_dna_from_location(origin_dna, cur_loc)
-            if cds_dna:
-                prot = translate_cds(cds_dna, codon_start=cur_codon_start)
-
-        prot = prot.replace(" ", "").replace("\n", "").strip().upper()
-        # Remove trailing '*' if present
-        if prot.endswith("*"):
-            prot = prot[:-1]
-        if prot and len(prot) >= min_aa:
-            proteins.append(prot)
-
-        # reset
-        cur_loc = None; cur_translation = None; cur_codon_start = 1; cur_is_pseudo = False
-        reading_translation = False; trans_buf = []
+        prot: str | None = None
+
+        if cur_translation is not None:
+            prot = _normalize_prot(cur_translation)
+            stats["prot_from_translation"] += 1
+
+        if prot is None:
+            if require_translation:
+                stats["cds_no_translation"] += 1
+            else:
+                if not origin_dna:
+                    stats["cds_no_origin"] += 1
+                else:
+                    s, e, is_comp = _parse_loc_range(loc_raw)
+                    if s is not None and e is not None:
+                        cds_dna = origin_dna[s-1:e]
+                        if is_comp:
+                            cds_dna = reverse_complement(cds_dna)
+                        prot = translate_cds(cds_dna, codon_start=cur_codon_start)
+                        stats["prot_from_dna"] += 1
+
+        if prot is not None:
+            prot = _normalize_prot(prot)
+            if _passes_filters(prot):
+                proteins.append(prot)
+                stats["prot_kept"] += 1
+
+        cur_loc_raw = None
+        cur_translation = None
+        reading_translation = False
+        trans_buf = []
 
-    with open(path, "r", encoding="utf-8", errors="ignore") as f:
+    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
         for line in f:
-            if line.startswith("FEATURES"):
+            if line.startswith('FEATURES'):
                 in_features = True
                 continue
-            if line.startswith("ORIGIN"):
+            if line.startswith('ORIGIN'):
                 in_origin = True
-                # end of FEATURES parsing
-                in_features = False
-                # flush any CDS we were building
-                if reading_translation and trans_buf:
-                    cur_translation = "".join(trans_buf)
-                flush_cds()
+                if in_features:
+                    _flush_current()
                 continue
             if in_origin:
-                # no need to parse further here
                 continue
             if not in_features:
                 continue
 
-            # New feature begins at column 6 (5 spaces) with a key
-            if line.startswith("     ") and len(line) > 5 and line[5] != " ":
-                # starting a new feature; flush previous CDS if any
-                if reading_translation and trans_buf:
-                    cur_translation = "".join(trans_buf)
-                flush_cds()
-
-                key = line[5:21].strip()
+            if line.startswith('     CDS'):
+                _flush_current()
                 loc = line[21:].strip()
-                if key == "CDS":
-                    cur_loc = loc
-                    cur_translation = None
-                    cur_codon_start = 1
-                    cur_is_pseudo = False
-                    reading_translation = False
-                    trans_buf = []
-                else:
-                    cur_loc = None
+                cur_loc_raw = loc
+                cur_translation = None
+                cur_codon_start = 1
+                cur_is_pseudo = False
+                reading_translation = False
+                trans_buf = []
                 continue
 
-            # Qualifiers: start around column 22 (21 spaces)
-            if cur_loc is not None and line.startswith("                     "):
+            if cur_loc_raw is not None and line.startswith('                     /'):
                 q = line.strip()
-
-                if reading_translation:
-                    # keep accumulating until closing quote
-                    if q.endswith('"'):
-                        trans_buf.append(q.rstrip('"'))
-                        cur_translation = "".join(trans_buf)
+                if q.startswith('/pseudo'):
+                    cur_is_pseudo = True
+                elif q.startswith('/codon_start='):
+                    m = re.search(r'/codon_start=(\d+)', q)
+                    if m:
+                        try:
+                            cur_codon_start = int(m.group(1))
+                        except Exception:
+                            cur_codon_start = 1
+                elif q.startswith('/translation='):
+                    # /translation may span multiple lines until closing quote
+                    reading_translation = True
+                    after = q[len('/translation='):]
+                    trans_buf = [after]
+                    if after.endswith('"') and after.count('"') >= 2:
                         reading_translation = False
+                        cur_translation = "".join(trans_buf)
                         trans_buf = []
-                    else:
-                        trans_buf.append(q)
-                    continue
-
-                if q.startswith("/pseudo") or q.startswith("/pseudogene"):
-                    cur_is_pseudo = True
-                    continue
-                if q.startswith("/codon_start="):
-                    try:
-                        cur_codon_start = int(q.split("=", 1)[1].strip().strip('"'))
-                    except Exception:
-                        cur_codon_start = 1
-                    continue
-                if q.startswith("/translation="):
-                    val = q.split("=", 1)[1].lstrip()
-                    # translation is quoted and can span lines
-                    if val.startswith('"'):
-                        val = val[1:]
-                    if val.endswith('"'):
-                        cur_translation = val.rstrip('"')
+                else:
+                    # any other qualifier ends translation capture
+                    if reading_translation:
+                        # translation continues only on non-qualifier lines
+                        pass
+
+            elif cur_loc_raw is not None and reading_translation:
+                # continuation lines for translation are indented but not qualifiers
+                if line.startswith('                     '):
+                    piece = line.strip()
+                    trans_buf.append(piece)
+                    joined = "".join(trans_buf)
+                    if '"' in joined and joined.strip().endswith('"'):
                         reading_translation = False
+                        cur_translation = joined
+                        trans_buf = []
+                else:
+                    # stop if indent breaks
+                    reading_translation = False
+                    if trans_buf:
+                        cur_translation = "".join(trans_buf)
                         trans_buf = []
-                    else:
-                        reading_translation = True
-                        trans_buf = [val]
-                    continue
 
-    return proteins
+    # flush at EOF
+    _flush_current()
+
+    return proteins, stats
+
+
 # -----------------------------
 # Base encoding
 # -----------------------------
@@ -560,6 +652,14 @@
     tokenizer: str = "base",
     frame_offset: int = 0,
     min_orf_aa: int = 90,
+    # GenBank/CDS-only proteome controls (apply when tokenizer=aa and source=genbank)
+    protein_strict_cds_only: bool = False,
+    protein_require_translation: bool = False,
+    protein_reject_partial: bool = True,
+    protein_require_start_m: bool = True,
+    protein_x_free: bool = True,
+    protein_min_aa: int | None = None,
+    protein_max_aa: int | None = None,
     source: str = "fasta",
     save_to_disk: bool = True,
     out_path: Optional[str] = None,
@@ -590,16 +690,42 @@
     elif tok == "aa":
         proteins: List[str] = []
         if src == "genbank" and gb_for_proteins is not None:
+            # Prefer GenBank CDS translations; optionally enforce strict CDS-only mode.
+            cds_min = int(protein_min_aa) if protein_min_aa is not None else int(min_orf_aa)
             try:
-                proteins = extract_cds_proteins_from_genbank(gb_for_proteins, min_aa=min_orf_aa)
-                if proteins:
-                    logging.info(f"{accession}: extracted CDS proteins from GenBank: {len(proteins)} (min_aa={min_orf_aa})")
-                else:
-                    logging.warning(f"{accession}: GenBank contained no CDS translations >= {min_orf_aa}aa; falling back to naive ORFs.")
+                proteins, stats = extract_cds_proteins_from_genbank(
+                    gb_for_proteins,
+                    min_aa=cds_min,
+                    max_aa=protein_max_aa,
+                    require_translation=bool(protein_require_translation),
+                    reject_partial=bool(protein_reject_partial),
+                    require_start_m=bool(protein_require_start_m),
+                    x_free=bool(protein_x_free),
+                )
+                logging.info(
+                    f"{accession}: GenBank CDS kept={stats.get('prot_kept',0)}/{stats.get('cds_total',0)} "
+                    f"(tr={stats.get('prot_from_translation',0)} dna={stats.get('prot_from_dna',0)} "
+                    f"pseudo={stats.get('cds_pseudo',0)} partial={stats.get('cds_partial',0)} no_tr={stats.get('cds_no_translation',0)}) "
+                    f"min={cds_min} max={protein_max_aa} filters: startM={protein_require_start_m} xfree={protein_x_free} "
+                    f"partial_reject={protein_reject_partial} require_translation={protein_require_translation}"
+                )
             except Exception as e:
+                if protein_strict_cds_only:
+                    raise
                 logging.warning(f"{accession}: failed to parse GenBank CDS ({e}); falling back to naive ORFs.")
                 proteins = []
+
+            if protein_strict_cds_only and not proteins:
+                raise ValueError(
+                    f"{accession}: strict CDS-only mode produced 0 proteins after filters. "
+                    f"Try relaxing filters (e.g., --no-x-free, --no-require-start-m, lower --min-protein-aa) or disable --strict-cds."
+                )
         if not proteins:
+            if src == "genbank" and bool(protein_strict_cds_only):
+                raise ValueError(
+                    f"{accession}: strict CDS-only mode produced 0 proteins (no ORF fallback). "
+                    "Disable --strict-cds or switch to --source fasta if you want naive ORF discovery."
+                )
             proteins = find_orfs_proteins(seq, min_orf_aa=min_orf_aa)
         encoded = encode_proteins_aa_windows(proteins, window_aa=window_size, stride_aa=stride)
         logging.info(
